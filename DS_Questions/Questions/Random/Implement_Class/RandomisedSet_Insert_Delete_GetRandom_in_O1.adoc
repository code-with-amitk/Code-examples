:toc:
:toclevels: 6

== link:https://leetcode.com/problems/insert-delete-getrandom-o1/[380. Insert Delete GetRandom O(1)]
- Implement the RandomizedSet class:
  - RandomizedSet() Initializes the RandomizedSet object.
  - bool insert(int val): Inserts val into the set if not present. Returns true if the item was not present, false otherwise.
  - bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
  - int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.

```c
Example 1:
Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
```

== Approach unordered_map<int, vector<int>>::iterator> + vector<int>
=== Logic
* insert(): can be carried in O(1)
* getRandom(): 
  - _Problem_: getRandom() cannot be carried in O(1) in hashset or hashmap, because we need to know what elements are present in hash before we can get random and that will take O(n)
** Solution
```c
- Use vector to store indexes of elements present in unordered_map
- Unordered_map<key=element, value=index_inside_vector_storing_the_element>
- Using this we can do getRandom() in vector in O(1) time

4,9,1,5
  unordered_map <element, index_in_vector>
  <5, 3> , <4, 0> , <1, 2>, <9, 1>
  
vector <int>
    element   4    9    1    5
    --------|---|----|----|-----|
    index     0    1    2    3
```
* remove(ele): Eg: remove(9)
```
- Search `<key,value>` in map. Found `<key=9,val=1>`
- Goto index=val=1 in vector.
- copy last element to present element and pop_back in vector.
- Remove element from unordered_map and Update mapping.

After copy, vector:
    element   4    5    1    5
    --------|---|----|----|-----|
    index     0    1    2    3

After pop_back, vector:                   //2a
    element   4    5    1  
    --------|---|----|----|
    index     0    1    2  

Update, unoredered_map:
    key=element              5      4     1     //2b
    ----------------------|------|-----|------|
    value=index_in_vector    1      0     2    
```
=== Complexity
* Time: Insert,Delete,getRandom: O(1)
* Space: O(2n)

=== Code
==== CPP
```cpp
//RandomizedSet.cpp
class RandomizedSet {
public:
    RandomizedSet():seed((random_device())()) {}

    bool insert(int val) {
      if (um.find(val) != um.end())
        return false;

      vec.emplace_back(val);
      um[val] = vec.size()-1;
      return true;
    }

    bool remove(int val) {
      if (!um.count(val))       //if val not present return false
        return false;

      vec[um[val]] = vec.back();
      um[vec.back()] = um[val];
      vec.pop_back();
      um.erase(val);
      return true;
    }

    int getRandom() {
  //rand() is considered harmful
  //https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful
  //    return vec[rand()%vec.size()];
  
      return vec[uniform_int_distribution<>(0, vec.size()-1)(seed)];
    }
private:
                //element, index
  unordered_map<int, int> um;
  vector<int> vec;
  default_random_engine seed;
};

//main.cpp
#include"RandomizedSet.cpp"
#include <gtest/gtest.h>
TEST(Random, case1) {
  {
             //(Expected_Output, function call)
    RandomizedSet obj;
    EXPECT_EQ(true, obj.insert(1));
    EXPECT_EQ(false, obj.remove(2));
    EXPECT_EQ(true, obj.insert(2));
    EXPECT_EQ(1, obj.getRandom());
    EXPECT_EQ(true, obj.remove(1));
    EXPECT_EQ(false, obj.insert(2));
    EXPECT_EQ(2, obj.getRandom());
    EXPECT_EQ(2, obj.getRandom());
  }
};  
int main(int argc, char **argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}

//CMakeLists.txt
cmake_minimum_required(VERSION 2.6)

# Locate GTest
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})

# Link runTests with what we want to test and the GTest and pthread library
add_executable(runTests main.cpp)
target_link_libraries(runTests ${GTEST_LIBRARIES} pthread)
```

==== Rust
link:/Languages/Programming_Languages/Rust/Crates_Packages_Modules[rand, thread_rng]
```rs
use std::{collections::HashMap, convert::TryInto};
use rand::{thread_rng, Rng};

struct RandomizedSet {
    um : HashMap <i32, i32>,
    v: Vec<i32>,
}

impl RandomizedSet {
    fn new() -> Self {
        Self {
            v: vec![],
            um: HashMap::new()
        }
    }
    
    fn insert(&mut self, val: i32) -> bool {
        match self.um.get(&val) {
            Some(_) => false,
            None => {
                self.v.push(val);
                self.um.insert(val, (self.v.len()-1).try_into().unwrap());
                true
            }
        }
    }
    
    fn remove(&mut self, val: i32) -> bool {
        return match self.um.get(&val){     //Get value of key
            None => false,
            Some(index) => {
                self.v[*index as usize] = self.v[self.v.len()-1]; //Copy last 
                self.um.insert(self.v[self.v.len()-1], *index);
                self.v.pop();
                self.um.remove(&val);
                true
            }
        }
    }
    
    fn get_random(&self) -> i32 {
        self.v[thread_rng().gen_range(0..self.v.len())]
    }
}

#[cfg(test)]                               //Automated tests run with `cargo test`
mod all_tests {
    use super::*;

    #[test]
    fn test1 () {
        let mut obj = RandomizedSet::new();
        assert_eq!(true, obj.insert(1));
        assert_eq!(false, obj.remove(2));
        assert_eq!(true, obj.insert(2));
        assert_eq!(1, obj.get_random());
        assert_eq!(true, obj.remove(1));
        assert_eq!(false, obj.insert(2));
        assert_eq!(2, obj.get_random());
        assert_eq!(2, obj.get_random());
    }
}

fn main(){
    let mut obj = RandomizedSet::new();
    println!("{}", obj.insert(1));
}
```
